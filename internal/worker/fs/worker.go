package fs

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/fsnotify/fsnotify"
	"io"
	"os"
	"path"
	"sync"
	"time"
)

const (
	DEFAULT_PATH           = "./"
	DEFAULT_RECURSIVE      = false
	WIP_DURATION           = 3 * time.Second
	PEER_COOLDOWN_DURATION = 5 * time.Second
	CHUNK_SIZE             = 1 << 15
)

type WorkerPayload struct {
	Event    fsnotify.Event
	FileData []byte
}

type WipPayload struct {
	event fsnotify.Event
	time  time.Time
}

type FsWorker struct {
	directory                string
	recursive                bool
	updates                  chan *fsnotify.Event
	watcher                  *fsnotify.Watcher
	wipUpdates               chan *fsnotify.Event
	wipStorage               *sync.Map
	peerReceivedEventStorage *sync.Map
}

func encodePayload(payload WorkerPayload) ([]byte, error) {
	buff := bytes.Buffer{}
	err := json.NewEncoder(&buff).Encode(payload)

	return buff.Bytes(), err
}

func decodePayload(b []byte) (WorkerPayload, error) {
	var wPayload WorkerPayload
	err := json.NewDecoder(bytes.NewReader(b)).Decode(&wPayload)

	return wPayload, err
}

func (receiver *FsWorker) ProducePayload() ([]byte, error) {
	for {
		select {
		case event := <-receiver.updates:
			wPayload := WorkerPayload{
				Event: *event,
			}
			if _, ok := receiver.peerReceivedEventStorage.Load(event.Name); ok {
				// This update has been generated by our activity (passed from other client)
				break
			}
			if event.Has(fsnotify.Create) || event.Has(fsnotify.Write) {
				fmt.Printf("Event %v should be sent, reading bytes from it\n", event)
				file, err := os.Open(event.Name)
				if err != nil {
					return nil, err
				}
				b, err := io.ReadAll(file)
				if err != nil {
					return nil, err
				}

				wPayload.FileData = b

			}

			fmt.Printf("Sending payload to peer\n")
			b, err := encodePayload(wPayload)
			fmt.Printf("Payload encoded to byte array with size %v\n", len(b))
			if len(b) > CHUNK_SIZE {
				fmt.Printf("Can not send byte array length of %v, max size for file is %v \n", len(b), CHUNK_SIZE)
				return make([]byte, 0), nil
			}
			return b, err
		}
	}
}

func (receiver *FsWorker) ConsumePayload(bytes []byte) error {
	fmt.Printf("Payload decoded from byte array with size %v\n", len(bytes))
	payload, err := decodePayload(bytes)
	if err != nil {
		return err
	}

	fmt.Printf("Received payload from peer\n")

	// This is needed for producer to notice that some of the updates
	// Which are generated by other peer's activity should not be re-transmitted
	receiver.peerReceivedEventStorage.Store(payload.Event.Name, true)
	defer func() {
		time.Sleep(PEER_COOLDOWN_DURATION)
		fmt.Printf("Removing file Event %v from peerReceivedEventStorage\n", payload.Event.Name)
		receiver.peerReceivedEventStorage.Delete(payload.Event.Name)
	}()

	if payload.Event.Has(fsnotify.Remove) {
		fmt.Printf("Delete Event was received from peer for file %v\n", payload.Event.Name)
		err := os.Remove(payload.Event.Name)
		if err != nil {
			return err
		}
	}
	if payload.Event.Has(fsnotify.Create) || payload.Event.Has(fsnotify.Write) {
		fmt.Printf("Write/Create file was received from peer for file %v\n", payload.Event.Name)
		file, err := os.Create(payload.Event.Name)
		if err != nil {
			return err
		}
		if len(payload.FileData) != 0 {
			fmt.Printf("Payload contianed bytes, writing them to created file %v\n", payload.Event.Name)
			_, err = file.Write(payload.FileData)
			if err != nil {
				return err
			}
			file.Close()
		}

	}

	return nil
}

func New(directory string, recursive bool) (*FsWorker, error) {
	fsWorker := FsWorker{
		directory:                directory,
		recursive:                recursive,
		updates:                  make(chan *fsnotify.Event),
		wipUpdates:               make(chan *fsnotify.Event),
		wipStorage:               &sync.Map{},
		peerReceivedEventStorage: &sync.Map{},
	}

	err := fsWorker.init()
	if err != nil {
		return nil, err
	}

	return &fsWorker, nil
}

func (receiver *FsWorker) checkAndHandleDir(event *fsnotify.Event) error {
	p := path.Join(receiver.directory, event.Name)
	fileInfo, err := os.Stat(p)

	if err != nil {
		if os.IsNotExist(err) {
			watched := func() bool {
				ls := receiver.watcher.WatchList()
				for _, el := range ls {
					if el == p {
						return true
					}
				}

				return false
			}()
			if watched {
				fmt.Printf("Folder %v has been watched before, removing it from watchers\n", p)
				err = receiver.watcher.Remove(p)
			}

			if err != nil {
				return err
			}
		} else {
			return err
		}

	}

	if !fileInfo.IsDir() {
		fmt.Printf("File %v was not directory, will not add watcher to it\n", p)
		return nil
	}

	fmt.Printf("Adding watcher for directory %v\n", p)
	return receiver.watcher.Add(p)
}

func (receiver *FsWorker) init() error {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return err
	}

	receiver.watcher = watcher

	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}

				fmt.Printf("Got Event for file %v\n", event.Name)

				if receiver.recursive {
					err = receiver.checkAndHandleDir(&event)
					if err != nil {
						fmt.Fprintf(os.Stderr, "Error while registering watcher to subdirectory: %v", err)
					}
				}

				if event.Has(fsnotify.Chmod) {
					//TODO: Right now just not sending chmod is ok, might need to change this later
					continue
				}

				fmt.Printf("Adding Event %v to WIP storage\n", event)
				receiver.wipStorage.Store(event.Name, WipPayload{event: event, time: time.Now().Add(WIP_DURATION)})
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}
				fmt.Fprintf(os.Stderr, "Error while getting events from watcher: %v", err)
			}

		}
	}()

	go func() {
		ticker := time.NewTicker(WIP_DURATION)
		for range ticker.C {
			curTime := time.Now()
			receiver.wipStorage.Range(func(key, value any) bool {
				v, _ := value.(WipPayload)

				if curTime.After(v.time) {
					fmt.Printf("File %v didn't update since %v, %v WIP duration has passed, adding it to updates\n", v.event.Name, v.time, WIP_DURATION)
					receiver.updates <- &v.event
					receiver.wipStorage.Delete(key)
				}

				return true
			})
		}
	}()

	_, err = os.Stat(receiver.directory)
	if os.IsNotExist(err) {
		fmt.Printf("Directory %v didn't exist, creating now\n", receiver.directory)
		err = os.Mkdir(receiver.directory, os.ModePerm)
		if err != nil {
			return err
		}
	}

	return watcher.Add(receiver.directory)
}
