package worker

import (
	"bytes"
	"encoding/json"
	"github.com/fsnotify/fsnotify"
	"github.com/sirupsen/logrus"
	"io"
	"os"
	"path"
	"sync"
	"time"
	"webrtc-playground/internal/logger"
)

const (
	wipDuration          = 3 * time.Second
	peerCooldownDuration = 5 * time.Second
	chunkSize            = 1 << 15
)

type WorkerPayload struct {
	Event    fsnotify.Event
	FileData []byte
}

type WipPayload struct {
	event fsnotify.Event
	time  time.Time
}

type FSWorker struct {
	directory                string
	recursive                bool
	updates                  chan *fsnotify.Event
	watcher                  *fsnotify.Watcher
	wipUpdates               chan *fsnotify.Event
	wipStorage               *sync.Map
	peerReceivedEventStorage *sync.Map
}

func encodePayload(payload WorkerPayload) ([]byte, error) {
	buff := bytes.Buffer{}
	err := json.NewEncoder(&buff).Encode(payload)

	return buff.Bytes(), err
}

func decodePayload(b []byte) (WorkerPayload, error) {
	var wPayload WorkerPayload
	err := json.NewDecoder(bytes.NewReader(b)).Decode(&wPayload)

	return wPayload, err
}

func (receiver *FSWorker) ProducePayload() ([]byte, error) {
	for {
		select {
		case event := <-receiver.updates:
			wPayload := WorkerPayload{
				Event: *event,
			}
			if _, ok := receiver.peerReceivedEventStorage.Load(event.Name); ok {
				// This update has been generated by our activity (passed from other client)
				break
			}
			if event.Has(fsnotify.Create) || event.Has(fsnotify.Write) {
				logger.Logger.WithField("event", event).Info("Event should be sent, reading bytes from it")
				file, err := os.Open(event.Name)
				if err != nil {
					return nil, err
				}
				b, err := io.ReadAll(file)
				if err != nil {
					return nil, err
				}

				wPayload.FileData = b

			}

			logger.Logger.Info("Sending payload to peer")
			b, err := encodePayload(wPayload)
			logger.Logger.WithField("len", len(b)).Info("Payload encoded to byte array")
			if len(b) > chunkSize {
				logger.Logger.WithFields(logrus.Fields{
					"len":       len(b),
					"chunkSize": chunkSize,
				}).Warn("byte array length exceeds chunk size")
				return make([]byte, 0), nil
			}
			return b, err
		}
	}
}

func (receiver *FSWorker) ConsumePayload(bytes []byte) error {
	logger.Logger.Info("Received payload from peer")
	payload, err := decodePayload(bytes)
	if err != nil {
		return err
	}
	logger.Logger.WithField("len", len(bytes)).Info("Payload decoded from byte array")

	// This is needed for producer to notice that some of the updates
	// Which are generated by other peer's activity should not be re-transmitted
	receiver.peerReceivedEventStorage.Store(payload.Event.Name, true)
	defer func() {
		time.Sleep(peerCooldownDuration)
		logger.Logger.WithField("name", payload.Event.Name).Info("Removing file Event from peerReceivedEventStorage")
		receiver.peerReceivedEventStorage.Delete(payload.Event.Name)
	}()

	if payload.Event.Has(fsnotify.Remove) {
		logger.Logger.WithField("name", payload.Event.Name).Info("Delete Event was received from peer for file")
		err := os.Remove(payload.Event.Name)
		if err != nil {
			return err
		}
	}
	if payload.Event.Has(fsnotify.Create) || payload.Event.Has(fsnotify.Write) {
		logger.Logger.WithField("name", payload.Event.Name).Info("Write/Create file was received from peer for file")
		file, err := os.Create(payload.Event.Name)
		if err != nil {
			return err
		}
		if len(payload.FileData) != 0 {
			logger.Logger.WithField("name", payload.Event.Name).Info("Payload contains bytes, writing them to created file")
			_, err = file.Write(payload.FileData)
			if err != nil {
				return err
			}
			file.Close()
		}

	}

	return nil
}

func NewFSWorker(directory string, recursive bool) (*FSWorker, error) {
	fsWorker := FSWorker{
		directory:                directory,
		recursive:                recursive,
		updates:                  make(chan *fsnotify.Event),
		wipUpdates:               make(chan *fsnotify.Event),
		wipStorage:               &sync.Map{},
		peerReceivedEventStorage: &sync.Map{},
	}

	err := fsWorker.init()
	if err != nil {
		return nil, err
	}

	return &fsWorker, nil
}

func (receiver *FSWorker) checkAndHandleDir(event *fsnotify.Event) error {
	p := path.Join(receiver.directory, event.Name)
	fileInfo, err := os.Stat(p)

	if err != nil {
		if os.IsNotExist(err) {
			watched := func() bool {
				ls := receiver.watcher.WatchList()
				for _, el := range ls {
					if el == p {
						return true
					}
				}

				return false
			}()
			if watched {
				logger.Logger.WithField("path", p).Info("Folder has been watched before, removing it from watchers")
				err = receiver.watcher.Remove(p)
			}

			if err != nil {
				return err
			}
		} else {
			return err
		}

	}

	if !fileInfo.IsDir() {
		logger.Logger.WithField("path", p).Info("File was not a directory, will not add watcher to it")
		return nil
	}

	logger.Logger.WithField("path", p).Info("Adding watcher for directory")
	return receiver.watcher.Add(p)
}

func (receiver *FSWorker) init() error {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		return err
	}

	receiver.watcher = watcher

	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}

				logger.Logger.WithField("name", event.Name).Info("Got event for file")

				if receiver.recursive {
					err = receiver.checkAndHandleDir(&event)
					if err != nil {
						logger.Logger.WithError(err).Error("Error while registering watcher to subdirectory")
					}
				}

				if event.Has(fsnotify.Chmod) {
					//TODO: Right now just not sending chmod is ok, might need to change this later
					continue
				}

				logger.Logger.WithField("event", event).Info("Adding Event to WIP storage")
				receiver.wipStorage.Store(event.Name, WipPayload{event: event, time: time.Now().Add(wipDuration)})
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}
				logger.Logger.WithError(err).Error("Error while getting events from watcher")
			}

		}
	}()

	go func() {
		ticker := time.NewTicker(wipDuration)
		for range ticker.C {
			curTime := time.Now()
			receiver.wipStorage.Range(func(key, value any) bool {
				v, _ := value.(WipPayload)

				if curTime.After(v.time) {
					logger.Logger.WithFields(logrus.Fields{
						"name":         v.event.Name,
						"timestamp":    v.time,
						"wip_duration": wipDuration,
					}).Info("File didn't update since timestamp, WIP duration has passed, adding it to updates")
					receiver.updates <- &v.event
					receiver.wipStorage.Delete(key)
				}

				return true
			})
		}
	}()

	_, err = os.Stat(receiver.directory)
	if os.IsNotExist(err) {
		logger.Logger.WithField("directory", receiver.directory).Info("Director didn't exist, creating it now")
		err = os.Mkdir(receiver.directory, os.ModePerm)
		if err != nil {
			return err
		}
	}

	return watcher.Add(receiver.directory)
}
